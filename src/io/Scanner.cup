 package io;

import java_cup.runtime.*;
import java.lang.String;
import absynt.*;
import utils.*;
import java.io.*;

/**
 * Offers the methods  parseFile and parseExpression 
 *
 * @author Martin Steffen
 * @version $Id: Scanner.cup,v 1.4 2001-06-13 15:25:40 swprakt Exp $
 *
 * */

action code {:
    String tab = "";
       

/* --- removed  */    int state_counter = 0;

    
    private void more(){
        tab = tab + "  ";
    }
    
    private void less(){
        tab = tab.substring(0, tab.length()-2);
    }

:}

parser code {:
    Yylex lexer;

    public void report_fatal_error(String message, Object info) throws ParseException{
        System.err.println(message);
        throw new ParseException(message);
    }

	public void report_error(String message, Object info){
	    System.err.println("[modul parser2] "+message);
	}

	public void syntax_error(Symbol cur_token){
        report_error("Syntax Fehler! aktuelles Symbol: "+cur_token, null);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws ParseException{
        done_parsing();       
        report_fatal_error("[modul parser2] Parsing wird abgebrochen", null);
    }


   /** 
    * public method to parse a file
    *
    * @parameter 
    * sourcefile - file to parse
    * @return 
    * abstract syntax tree with absynt.sfc as root
    * @throws 
    * java.Exception when broken.
    */
    public absynt.SFC  parseFile(java.io.File sourcefile) throws Exception {
        lexer   = new Yylex(new FileInputStream(sourcefile));
	setScanner(lexer);
        absynt.SFC  sfc = (absynt.SFC)parse().value;
	return sfc;
    }

    
    /**
     * public method to parse a single expression<br><br>
     *
     * @parameter
     * The string to parse
     * @return 
     * an absynt.Expr*
     * @throws
     * java.Exception when not parseable.
     */
    public absynt.Expr parseExpression(java.lang.String expression) throws Exception {
      lexer = new Yylex(new StringReader(expression));
      setScanner(lexer);
      absynt.Expr expr = (absynt.Expr)parse().value;
      return expr;
    }
    
//      public static void main(String args[]) throws Exception {
//          new Parser().parseFile(new File(args[0]));    
//      //    new Parser().parseExpression(args[0]);
//      }

:}

/** 
 * Terminals 
 */ 
terminal         SFC, LBRACKET, RBRACKET, ASSIGN;
terminal         LPAREN, RPAREN,  COMMA, SEM, FROMTO;  
terminal         INIT, WHEN, ACTIONS, BEGIN, VARS, STEPS, TRANSITIONS;
terminal         INT, BOOL, GET, NEQ, OR, PLUS, TIMES;
terminal         AND, DIV, EQ, GEQ, GREATER, LEQ, LESS, MINUS, NEG;
terminal         TRUE, FALSE;

terminal String  IDENT;
terminal Integer INTEGER;



/** 
 * non-terminals
 */ 
non terminal    stmt_list, stmt, block, atomic, if_else_stmt, loop;
non terminal    input, output, assertion, var_dec, assignment;

/** 
 * Nichtterminale mit Typ
 */ 
non terminal    absynt.SFC        sfc;
non terminal    absynt.SFC        program;
non terminal    absynt.Expr       expr;
non terminal    Integer           op;




precedence left BOOL, INT;
precedence left IDENT, error;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left AND, OR, NEQ, LESS, LEQ, GREATER, GEQ, EQ;
precedence left NEG;




start with sfc;



sfc          ::= program:p {: RESULT=p; :}
             ;

/** 
 * Produktion:
 * Program   ::= "program" IDENT "[" "]" ""
 */
program      ::= SFC IDENT:name LBRACKET
                 {: System.out.println ("Programm \""+name+"\"{"); more(); :}
                 INTEGER:i
                 VARS:v
                 RBRACKET
                 {: 
	    	    less();
                    System.out.println ("\n} /* Ende "+name+" */"); 
                    // p.name = name; 
		    RESULT = new absynt.SFC(); 
                 :} 

             ;

