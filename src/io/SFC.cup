
/**
 * Grammar (yacc) definition of the syntax of textual sfc's.
 * Offers the methods  parseFile and parseExpression 
 *
 * @author Karsten Stahl, Martin Steffen
 * @version $Id: SFC.cup,v 1.10 2001-07-01 08:44:58 swprakt Exp $
 *
 * The grammar definition contains 4 parts:
 *    -  initialization declarations and how to generate the parser
 *    -  declaration of terminals and non-terminals
 *    -  precedence, associativity
 *    -  grammar proper
 **/



/*  ---- Preliminaries to set up and use the scanner.  ---- */


package io;

import java_cup.runtime.*;
import java.lang.String;
import absynt.*;
import utils.*;
import java.util.*;
import java.io.*;


/**
* The following 4 (optional) entries are for user-code insertions to the generated parser:
*   - init:   executed before start parsing
*   - scan:   how the parser asks for the next token
*   - action: code will be placed int the action class. Used as auxiliary
*             routines usable int the actions of the grammar.
*   - parser: code will be _directly_ placed int the parser class
**/


// init with {: io.scanner.init(); :}; 
// scan with {: return scanner.next_token(); :};  // equivalent to the default


action code {:
  String tab = "";
  /* --- removed  */    int state_counter = 0;

  private void more(){
    tab = tab + "  ";
  }
  
  private void less(){
    tab = tab.substring(0, tab.length()-2);
  }
  
  :}

parser code {:
  Yylex lexer;
  
  public void report_fatal_error(String message, Object info) throws ParseException{
    System.err.println(message);
    throw new ParseException(message);
  }
  
  public void report_error(String message, Object info){
    System.err.println("[modul parser2] "+message);
  }
  
  public void syntax_error(Symbol cur_token){
    report_error("Syntax Fehler! aktuelles Symbol: "+cur_token, null);
  }
  
  public void unrecovered_syntax_error(Symbol cur_token) throws ParseException{
    done_parsing();       
    report_fatal_error("[module io] fatal parsing error", null);
  }


   /** 
    * public method to parse a file
    *
    * @parameter 
    * sourcefile - file to parse
    * @return 
    * abstract syntax tree with absynt.sfc as root
    * @throws 
    * java.Exception when broken.
    */
  public absynt.SFC  parseFile(java.io.File sourcefile) throws Exception {
    lexer   = new Yylex(new FileInputStream(sourcefile));
    setScanner(lexer);
    absynt.SFC  sfc = (absynt.SFC)parse().value;
    return sfc;
  }
  
    /**
     * public method to parse a single expression
     *
     * @parameter
     * The string to parse
     * @return 
     * an absynt.Expr*
     * @throws
     * java.Exception when not parseable.
     */
  public absynt.Expr parseExpression(java.lang.String expression) throws Exception {
    lexer = new Yylex(new StringReader(expression));
    setScanner(lexer);
    absynt.Expr expr = (absynt.Expr)parse().value;
    return expr;
  }
  
  //      public static void main(String args[]) throws Exception {
  //          new Parser().parseFile(new File(args[0]));    
  //      //    new Parser().parseExpression(args[0]);
  //      }

  :}


/* ------ Declaration of terminals and non-terminals ----- */
/** 
 * The choice of names for the non-terminals is directly inspired
 * byte the extended abstract grammar.
 */ 
terminal         LBRACKET, RBRACKET, ASSIGN;
terminal         LPAREN, RPAREN,  COMMA, SEM, COLON, FROMTO;  
terminal         INIT, SKIP, WHEN, ACTIONS, BEGIN, END, VARS, STEPS, TRANSITIONS;
terminal         INT, BOOL, NEQ, OR, PLUS, TIMES;
terminal         AND, DIV, EQ, GEQ, GREATER, LEQ, LESS, MINUS, NEG;
terminal         TRUE, FALSE;

terminal String  IDENT;
terminal Integer INTEGER;

non terminal    absynt.SFC        sfc;
non terminal    absynt.SFC        program;
non terminal	absynt.Step	  istep;
non terminal	LinkedList	  steps, steplist, stepnames;
non terminal    absynt.Step       step;
non terminal	LinkedList	  transitions, transitionlist;
non terminal	LinkedList	  declist;
non terminal    absynt.Type       type;
non terminal    absynt.Constval   constval;
non terminal    LinkedList        declarations;
non terminal    Declaration       declaration;
non terminal    LinkedList        stepactionlist;
non terminal    absynt.StepAction stepaction;
non terminal    absynt.ActionQualifier  qualifier;
non terminal    LinkedList              actionlist,actions;
non terminal    absynt.Action           sfcaction;   //action a is reserved word
non terminal    LinkedList              sap, stmtlist;
non terminal    absynt.Stmt             stmt;
non terminal    absynt.Assign           assign;
non terminal    absynt.Transition       transition;

non terminal    absynt.Expr       expr;
non terminal    absynt.Variable   var;
non terminal    Integer           op;    // int does not work! RESULT must be an object


/* ---        precedences and associativity ------- */


precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left AND, OR, NEQ, LESS, LEQ, GREATER, GEQ, EQ;
precedence left NEG;


/* -----      The grammar proper ----------------- */
start with sfc;




/** 
 * Produktion:
 * Program   ::= "program" IDENT "[" "]" ""
 **/

sfc          ::= program:p {: RESULT=p; :}
                 ;


program      ::= BEGIN 
                 declist SEM
	         istep SEM
	         steps SEM
                 actions SEM
                 transitions
                 END;



/** program      ::= BEGIN
		 declist SEM
		 istep SEM
		 steps SEM
		 actions SEM
		 transitions SEM
		 END
		 ;
**/


declist      ::= VARS EQ LBRACKET  RBRACKET
              |  VARS EQ LBRACKET  declarations RBRACKET
		 ;
declarations ::= declaration
              |  declaration SEM declarations
		 ;

declaration  ::= IDENT:var COLON type:type EQ constval:val;
  

type         ::= INT 
              |  BOOL;


constval        ::= TRUE 
                 |  FALSE
	         |  INTEGER:i 
  ;



istep	     ::= INIT EQ IDENT:stepname // init = s1
                 {: 
		  RESULT = new absynt.Step(stepname);  // no actions yet int concrete syntax!
                 :} 
;

steps       ::=  STEPS EQ 
                 LBRACKET
                 steplist
                 RBRACKET
  ;

steplist    ::=  step
             |   step SEM steplist
  ;

step        ::=  LPAREN 
                 IDENT:s COMMA 
                 LBRACKET
                 stepactionlist
                 RBRACKET
                 RPAREN
  ;


stepactionlist   ::= stepaction
                   |  stepaction SEM stepactionlist
  ;

stepaction      ::= LPAREN
                      qualifier COMMA IDENT:a
                      RPAREN
  ;

qualifier       ::= IDENT:q       // not as reserved word
  ;


actions         ::= ACTIONS EQ
                    LBRACKET
                    actionlist
                    RBRACKET
  ;


actionlist      ::= sfcaction
                 |  sfcaction SEM actionlist
  ;

sfcaction       ::=  IDENT:a EQ
                     sap
  ;


sap             ::=  LBRACKET stmtlist RBRACKET
  ;

stmtlist        ::=  stmt
                 |   stmt SEM stmtlist
  ;

stmt            ::= SKIP
                 |  assign
  ;

assign          ::= IDENT:x ASSIGN expr:e
  ;

expr            ::= op expr
                 |  expr op expr
                 |  LPAREN expr RPAREN
                 |  var
                 | constval
  ;

op              ::= PLUS     {: RESULT= new Integer(absynt.Expr.PLUS); :}
                 |  MINUS    {: RESULT= new Integer(absynt.Expr.MINUS); :}
                 |  TIMES    {: RESULT= new Integer(absynt.Expr.TIMES); :}
                 |  DIV      {: RESULT= new Integer(absynt.Expr.DIV); :}
                 |  AND      {: RESULT= new Integer(absynt.Expr.AND); :}
                 |  OR       {: RESULT= new Integer(absynt.Expr.OR); :}
                 |  NEG      {: RESULT= new Integer(absynt.Expr.NEG); :}
                 |  LESS     {: RESULT= new Integer(absynt.Expr.LESS); :}
                 |  GREATER  {: RESULT= new Integer(absynt.Expr.GREATER); :}
                 |  LEQ      {: RESULT= new Integer(absynt.Expr.LEQ); :}
                 |  GEQ      {: RESULT= new Integer(absynt.Expr.GEQ); :}
                 |  EQ       {: RESULT= new Integer(absynt.Expr.EQ); :}
                 |  NEQ      {: RESULT= new Integer(absynt.Expr.NEQ); :}
  ;

var             ::= IDENT:v
  ;


transitions     ::=  TRANSITIONS EQ 
                     LBRACKET
                     transitionlist
                     RBRACKET
  ;

transitionlist  ::=  transition
                 |   transition SEM transitionlist
  ;

transition      ::=  LBRACKET stepnames RBRACKET FROMTO LBRACKET stepnames RBRACKET
                 |   LBRACKET stepnames RBRACKET FROMTO LBRACKET stepnames RBRACKET
                     WHEN expr
  ;
                  


stepnames       ::= IDENT:s
                 |  IDENT:s SEM stepnames
  ;
